https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md
위의 문서 번역

## AIP-61-Keyless account

### 개요 

> 우리가 해결하려는 문제와 어떻게 그 문제를 해결하고 있는지를 3-5문장으로 요약해보겠습니다.

현재 Aptos 계정을 보호하는 유일한 방법은 해당 계정과 연결된 비밀 키(SK)를 보호하는 것입니다. 하지만, 이는 말로는 간단하지만 실제로는 쉽지 않습니다. 실제로 비밀 키는 종종 분실되거나 도난당하며, 이로 인해 사용자가 계정을 설정할 때 니모닉을 기록하지 않는 등의 이유로 발생합니다. 이는 사용자의 계정이 분실 또는 도난당할 때 사용자를 이탈시키며, 사용자 유입을 불필요하게 어렵게 만듭니다.

이 AIP에서는 다음을 의존하여 계정 관리를 위한 보다 사용자 친화적인 접근 방식을 설명합니다:

1. 수정되지 않은 OpenID Connect(OIDC) 표준
2. 그것의 블록체인 응용 프로그램
3. 최근 OIDC 서명의 제로 지식 증명(ZKPoKs)에 대한 발전

구체적으로, 우리는 Aptos에서 기존의 OIDC 계정(즉, Google, GitHub 또는 Apple과 같은 OIDC 제공 업체와의 웹2 계정)을 통해 보호되는 키리스 계정을 가능하게 합니다. 요약하면, "당신의 블록체인 계정 = 당신의 OIDC 계정"입니다.

> 경고
> 
> 키리스 계정의 중요한 특성은 사용자의 OIDC 계정(예: alice@gmail.com)뿐만 아니라 OIDC 제공 업체에 등록된 관리 응용 프로그램(예: dapp의 dapp.xyz 웹사이트 또는 지갑의 모바일 앱)에도 바인딩된다는 것입니다. 다시 말해, 이것들은 응용 프로그램별 계정입니다. 따라서 계정의 관리 응용 프로그램이 사라지거나 OIDC 제공 업체 등록 자격 증명을 잃으면 이 응용 프로그램에 바인딩된 사용자는 대체 복구 경로가 제공되지 않는 한 접근할 수 없게 됩니다(아래 논의됨).

### 목표 

> 목표와 범위, 지표는 무엇인가요? 이 변경이 비즈니스 영향과 비즈니스 가치에 어떤 영향을 미칠 것으로 예상되나요?

1. 사용자 친화성:
	1. 블록체인 계정은 사용자 친화적인 OIDC 계정으로 지원되어야 하며, 이로 인해 쉽게 접근할 수 있어야 합니다(따라서 접근을 잃기가 어려워야 함) 
	2. 사용자가 지갑을 설치하지 않고도 dapp과 상호 작용할 수 있도록 지원: 즉, 지갑 없는 경험. 
	3. 사용자가 어떤 기기에서든 블록체인 계정에 쉽게 액세스할 수 있도록 함
2. 보안:
	1. 키리스 계정은 기본 OIDC 계정만큼 안전해야 함([여기 참조](#Compromised OIDC provider)) 
	2. 관리 응용 프로그램이 사라지면 키리스 계정을 복구할 수 있어야 함
3. 개인 정보:
	1. 키리스 계정 및 해당 트랜잭션은 사용자의 OIDC 계정(예: Google 사용자의 이메일 주소 또는 OAuth sub 식별자)에 대한 정보를 누설해서는 안 됨
	2. OIDC 제공 업체(예: Google)는 사용자의 트랜잭션 활동을 추적할 수 없어야 함
	3. 같은 사용자의 키리스 계정이 다른 관리 응용 프로그램과 연결되어도 체인 상에서 연결될 수 없어야 함
4. 효율성:
	1. 키리스 계정의 트랜잭션은 지갑/ dapp에 의해 효율적으로 생성되어야 함(< 1초) 및 Aptos 검증자에 의해 효율적으로 검증되어야 함(< 2밀리초)
5. 검열 방지:
	1. Aptos 검증자는 관리 응용 프로그램 또는 사용자의 신원에 따라 OpenID 트랜잭션에 우선적인 처리를 할 수 없어야 함
6. 탈중앙화:
	1. 키리스 계정은 절대로 탈중앙화될 수 없는 당사자의 존재를 요구해서는 안 됨

  
### 배경지식

#### OAuth와 OpenID Connect (OIDC)

이 글을 읽고 있는 사람은 OAuth 인증 프레임워크와 OIDC 프로토콜에 친숙한 사람이라는 것을 가정한다.

* OAuth 암시적 그랜트 플로우와 OAuth 인가 코드 그랜트 플로우의 보안에 대한 이해
* OAuth 클라이언트 등록(예: 관리 응용 프로그램의 `client_id`)
* JSON Web Tokens (JWTs)은 다음과 같은 구성요소로 이루어져 있으며
	* JWT 헤더
	- JWT 페이로드는 종종 간단히 "JWT"라고 부른다.
	- 헤더와 페이로드를 통한 JWT 서명은 종종 OIDC 서명이라고도 한다.
	- 헤더, 페이로드 및 서명의 조합을 서명된 JWT라고 부르는 경우가 많다.
	- See [an example here](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#JWT-header-and-payload-example)
- JWT 헤더 필드
- JWT 페이로드 필드
- 각 OIDC 공급자가 OpenID 구성 URL에 표시된 JWK 엔드포인트 URL에 게시하는 JSON 웹 키(JWK)

#### 술어

* OIDC 계정: Google과 같은 OIDC 공급자가 있는 Web2 계정(예: alice@gmail.com)
* Keyless 계정: 보안 및 활성성이 비밀 키가 아닌 OIDC 계정(예: Google 계정)으로 뒷받침되는 블록체인 계정입니다. 이 AIP의 핵심은 이러한 키리스 계정을 안전하게 구현하는 방법을 설명하는 것이다.
* Application-specific keyless accounts: keyless 계정은 사용자의 식별 정보 (예: alice@gmail.com)와 관리 응용 프로그램의 식별 정보 (예: dapp.xyz)에 모두 바인딩된다. 이는 계정에 액세스하기 위해 사용자의 식별 정보와 관리 응용 프로그램의 식별 정보에 대한 서명된 JWT 토큰이 제시되어야 함을 의미한다. 이러한 토큰은 사용자의 OIDC 제공 업체(예: Google)를 통해 관리 응용 프로그램에 로그인하여만 얻을 수 있다. 

#### tl;dr on OIDC (OIDC 요약, Too Long; Didn't Read)

이 AIP의 목적을 위해 OIDC에 대해 가장 중요한 점은 사용자의 OIDC 자격 증명(즉, Google 계정 비밀번호)을 학습하지 않고도 관리 응용 프로그램(예: dapp.xyz 또는 some-wallet.org 또는 모바일 앱)이 사용자를 로그인시킬 수 있다는 것이다. 중요한 점은 사용자가 성공적으로 로그인한 경우에만 관리 응용 프로그램(다른 사람이 아님)이 사용자가 로그인한 것을 공개적으로 검증 가능한 증명으로서 Google로부터 서명된 JWT를 받는다는 것이다.

이 AIP의 목적은 이 서명된 JWT가 해당 사용자와 관리 응용 프로그램과 연결된 키리스 계정의 트랜잭션을 인가하는 데 어떻게 사용될 수 있는지를 보여주는 것이다.

#### 영지식증명 (Zero-knowledge proofs)

영지식증명(ZKP) 시스템, 즉 관계에 대한 ZKP 시스템에 익숙하다고 가정합니다. R증명자는 **공개 입력을** 받은 **검증자를** 설득 할 수 있습니다 . x, 증명자는 **비공개 입력을 알고 있음** w 그렇게 𝑅(𝑥;𝑤)=1 (i.e., “it holds”)에 대한 어떠한 정보도 유출하지 않고 w관계가 유지된다는 사실을 넘어서 검증자에게 전달됩니다.

기타 ZKP 용어:

- **증명키** 와 **인증키**
- **관계별 신뢰할 수 있는 설정**

우리는 SNARK 친화적인 해시 함수를 가정합니다.시간zk이는 ZKP 내부에서 증명하는 것이 효율적입니다.

### Aptos 계정 및 거래 검증

Aptos에서 계정은 계정의 **인증 키가** 저장되는 주소 로 식별된다.
인증 키는 계정의 공개 키(PK) (예: PK 해시)에 대한 암호화학적으로 겹합된 커밋먼트이다.

당연히 계정을 **소유한 사용자는 해당** **비밀 키를** 관리하게 됩니다 .

Aptos 계정에 대한 액세스를 **승인** 하기 위해 거래에는 다음이 포함됩니다.

1. (a) 계정 _주소 및 (b)_ **거래 페이로드** (예: 이동 입력 함수 호출) 에 대한 디지털 **서명**
2. 계정 _주소 아래_ _인증키_ 에 커밋된 _공개_ 키

**거래가** 계정에 액세스할 수 있는 권한이 있는지 확인하기 위해 검증자는 다음을 수행합니다.

1. 트랜잭션에서 _공개 키를_ 가져오고 해당 유형에 따라 예상되는 _인증 키를 파생합니다._
2. 파생된 예상 _인증 키가_ 주소에 저장된 _인증 키_ 와 동일한 지 확인합니다.
3. 그들은 트랜잭션을 통해 가져온 _공개 키로_ _서명이 확인되는지 확인합니다._

### 범위

> 이 API는 다음 사항에 대해 다룹니다.

* 키리스 계정이 작동하는 방식의 세부 사항 설명
* 키리스 트랜잭션 인증기의 초기 Rust 구현 설명

### 범위에서 제외

> 어떤 것들을 하지 않기로 했으며 왜 그것들이 범위에서 제외되는지?

- DNS 및 X.509 인증서 생태계의 보안
    - 키리스 계정은 OAuth 및 OIDC에 의존하며, 이는 다시 DNS 및 X.509 인증서 생태계의 보안에 의존합니다.
    - 인터넷의 모든 소프트웨어가 이에 의존하기 때문에 이를 범위에서 제외하기로 했습니다.
- 정품 지갑 애플리케이션을 가장하는 악성 지갑 애플리케이션
    - 우리는 공격자가 Apple의 App Store와 같은 곳에 지갑의 등록된 OAuth client_id를 가장한 모바일 폰 앱을 게시할 수 없다고 가정합니다.
    - 우리는 공격자가 사용자를 속여 다른 애플리케이션의 OAuth client_id를 가장한 악성 데스크탑 앱을 설치하도록 할 수 없다고 가정합니다. 이러한 이유로, 데스크탑 애플리케이션은 매우 쉽게 가장될 수 있기 때문에 키리스 계정을 관리하기 위한 애플리케이션으로 사용하지 않을 것을 권장합니다.
- 키리스 계정에 필요한 보조 백엔드 구성 요소에 대한 심층 논의:
    - 페퍼 서비스(Pepper service)는 AIP-8112의 범위에 속하지만, 부록에서 개요를 제공합니다.
    - ZK 증명 서비스(ZK proving service)는 AIP-7513의 범위에 속하지만, 부록에서 개요를 제공합니다.
    - JSON 웹 키(JWK)에 대한 합의는 AIP-6714의 범위에 속하지만, 부록에서 개요를 제공합니다.
    - 우리의 Groth16 ZKP를 위한 신뢰 설정 MPC 세레모니 (Groth16 논의를 참조)
    - 페퍼 및 ZK 증명 서비스의 탈중앙화 계획

### 동기

> 이 변경의 추진 동기를 설명하십시오. 무엇을 성취합니까?

요약에서 설명한 바와 같이, 이 변경은 두 가지를 성취합니다:

1. 사용자가 (예를 들어) Google 계정으로 지갑이나 dapp에 로그인하여 온보딩을 훨씬 쉽게 만듭니다.
2. 비밀 키가 관련되지 않기 때문에 사용자가 계정을 잃어버리기 훨씬 어렵게 만듭니다.

> 이 제안을 수락하지 않으면 어떤 일이 발생할 수 있습니까?

이 제안을 수락하지 않으면 비밀 키를 기반으로 한 사용자 친화적이지 않은 계정 관리의 현 상태가 유지될 것입니다. 이는 Aptos 네트워크의 채택을 저해할 가능성이 큽니다. 많은 사용자가 공개 키 암호화의 복잡성 (예: 니모닉을 어떻게 보안할 것인가, 비밀 키가 무엇인가, 공개 키와 비밀 키는 어떻게 다른가)을 이해하지 못하기 때문입니다.

### 영향

> 이 변경에 영향을 받는 대상은 누구이며, 대상이 취해야 할 조치는 무엇입니까?

**Dapp 개발자**
- 키리스 계정 SDK에 익숙해져야 합니다.
- 원한다면, dapp에 지갑 없는 경험을 활성화하여 사용자가 지갑을 연결하지 않고도 OpenID 계정(예: Google 계정)을 통해 dapp에 직접 로그인할 수 있습니다.
- 이를 통해 사용자는 해당 dapp에 대한 dapp 전용 블록체인 계정에 접근할 수 있습니다. 이렇게 하면, 이 계정이 해당 dapp에만 범위가 제한되기 때문에 dapp은 복잡한 TXN 프롬프트 없이 사용자를 대신하여 "맹목적으로" 트랜잭션을 승인할 수 있습니다.

**지갑 개발자**
- 키리스 계정 SDK에 익숙해져야 합니다.
- 기본 사용자 온보딩 흐름을 키리스 계정 사용으로 전환하는 것을 고려해야 합니다.

**사용자**
- 키리스 계정의 보안 모델에 익숙해져야 합니다.
- 자신의 계정이 OpenID 계정(예: Google 계정)만큼 안전하다는 것을 이해해야 합니다.
- 관리 애플리케이션이 사용할 수 없게 되는 경우 계정을 복구하는 방법을 이해해야 합니다.

### 대안 해결책

이 제안을 대안 해결책보다 우선 제출한 이유를 설명하십시오. 왜 이것이 최선의 결과입니까?

#### 패스키(Passkeys)
사용자가 자신의 비밀 키를 관리할 필요를 없애는 대안 해결책으로는 패스키와 이를 기반으로 한 WebAuthn 표준이 있습니다. 패스키는 사용자의 클라우드(예: Apple의 iCloud, Google의 Password Manager 등)에 백업되는 애플리케이션 또는 웹사이트와 연결된 비밀 키입니다.

패스키는 원래 웹사이트의 비밀번호를 대체하기 위해 도입되었습니다. 웹사이트는 각 사용자를 비밀번호 대신 패스키 공개 키와 연관시킵니다. 이렇게 하면 사용자는 클라우드에 안전하게 백업된 해당 패스키 비밀 키를 사용하여 무작위 챌린지에 서명함으로써 웹사이트에 안전하게 인증할 수 있습니다.

블록체인 계정에 패스키를 활용하려는 자연스러운 경향이 있지만, 현재 패스키는 두 가지 단점이 있습니다. 첫째, 일부 플랫폼(예: Microsoft Windows)에서는 패스키가 항상 클라우드에 백업되지 않습니다. 둘째, 패스키는 교차 기기 문제를 도입합니다. 예를 들어, 사용자가 Apple 휴대폰에서 블록체인 계정을 생성하면 해당 패스키 비밀 키는 iCloud에 백업되지만, 사용자의 다른 Android 기기, Linux 기기 또는 Windows 기기에서는 접근할 수 없습니다. 패스키의 교차 플랫폼 백업 지원이 아직 구현되지 않았기 때문입니다.

미래에는 패스키를 사용하여 사용자의 니모닉을 암호화하여 추가 백업 옵션을 제공할 수 있습니다. 그러나 WebAuthn PRF 확장이 얼마나 널리 지원되는지는 명확하지 않습니다.

#### 다중 당사자 계산(MPC)
사용자가 자신의 비밀 키를 관리할 필요를 없애는 대안 해결책으로는 다중 당사자 계산(MPC) 서비스를 이용하여 사용자가 인증된 후 서명을 계산하는 방법이 있습니다.

일반적으로 사용자는 사용자 친화적인 방식으로 MPC에 인증해야 합니다(즉, SK를 관리하지 않고). 그렇지 않으면 MPC 시스템은 UX 문제를 해결하지 못하고 쓸모없게 됩니다. 따라서 대부분의 MPC 시스템은 서명하기 전에 사용자를 인증하기 위해 OIDC 또는 패스키를 사용합니다.

이에는 두 가지 문제가 있습니다. 첫째, MPC 시스템은 누가 언제 거래하는지 알게 됩니다. 즉, OIDC 계정과 해당하는 온체인 계정 주소를 알게 됩니다. 둘째, MPC 시스템은 불필요합니다. 사용자는 OIDC를 통해 직접 검증자에게 인증할 수 있기 때문입니다(이 AIP에서 주장한 바와 같이) 또는 패스키를 통해서도 가능합니다(위에서 언급한 대로).

다시 말해, 키리스 계정은 복잡한 MPC 서명 서비스를 필요 없이 OIDC를 통해 직접 사용자를 인증함으로써 이를 회피합니다. 실제로, 키리스 계정은 MPC 기반 계정보다 더 안전합니다. MPC 시스템의 손상은 계정 도난을 허용할 수 있기 때문입니다. 반면, 키리스 계정은 사용자의 OIDC 계정이 손상되거나 OIDC 제공자 자체가 손상되지 않는 한 도난당할 수 없습니다.

그럼에도 불구하고 키리스 계정은 분산된 페퍼 서비스와 ZK 증명 서비스에 의존합니다(부록 참조). 그러나:

- 증명 서비스는 브라우저나 휴대폰에서 ZKP를 계산할 때 성능을 위해 필요하며, ZKP 시스템이 최적화되면 미래에 제거될 수 있습니다.
- 페퍼 서비스는 MPC 서비스와 달리 보안에 민감하지 않습니다. 공격자가 이를 완전히 손상시키더라도 사용자의 OIDC 계정을 손상시키지 않는 한 사용자의 계정을 도난할 수 없습니다.
- 페퍼 서비스는 사용자가 페퍼 없이는 거래할 수 없기 때문에 생존성에 민감합니다. 간단한 VRF 기반 디자인을 통해 이를 탈중앙화하여 문제를 해결할 수 있습니다.
- MPC 시스템의 장점 중 하나는 MPC 노드가 TXN을 서명하기 전에 사기 감지를 수행할 수 있다는 것입니다. MPC에서 사기 감지를 수행하는 것과 지갑 또는 계정 추상화를 통해 사기 감지를 수행하는 것의 장점은 더 연구가 필요합니다.

#### HSM 또는 신뢰할 수 있는 하드웨어
근본적으로, 이 접근법은 MPC 접근법과 동일한 문제를 겪습니다. 사용자를 대신하여 서명할 수 있는 외부(하드웨어 기반) 시스템에 사용자를 인증하기 위해 사용자 친화적인 OIDC 기반 또는 패스키 기반 접근법을 사용해야 합니다.

따라서 이 외부 시스템(HSM)은 불필요한 실패 지점으로, 손상될 수 있습니다. 앞서 언급한 바와 같이, 우리의 접근법은 추가 인프라와 위험 없이 블록체인 검증자에게 사용자를 직접 인증합니다.

HSM 또는 신뢰할 수 있는 하드웨어의 장점은 구현 복잡성이 낮다는 것입니다. 또한, MPC 접근법과 달리 신뢰할 수 있는 하드웨어로는 프라이버시 보장이 더 쉬울 수 있습니다.

### 사양

> 문제를 어떻게 해결할 것인지 설명하십시오. 이 제안을 구현하는 방법을 정확하게 설명하십시오. 이 기능을 구현할 때 따라야 할 설계 원칙을 포함하십시오. 제안을 충분히 구체적으로 하여 다른 사람들이 이를 기반으로 구축하고 경쟁 구현을 도출할 수 있도록 하십시오.

아래에서는 키리스 계정이 구현되는 주요 개념을 설명합니다:

1. 키리스 계정의 공개 키란 무엇인가?
2. 이 공개 키로부터 인증 키는 어떻게 도출되는가?
3. OIDC 계정 거래에 대한 디지털 서명은 어떻게 생겼는가?

#### 공개 키 키리스 계정의 공개 키는 다음으로 구성됩니다:

1. `iss_val` : JWT의 `iss` 필드에 나타나는 OIDC 제공자의 정체성(예: [https://accounts.google.com](https://accounts.google.com/)), 이를 providerprovider로 표기합니다.
2. `addr_idc` : 다음에 대한 은닉 커밋먼트인 ID 커밋먼트(IDC):
    - OIDC 제공자가 발행한 소유 사용자 식별자(예: alice@gmail.com), 이를 `uid_val`로 표기합니다.
    - 사용자 식별자를 저장하는 JWT 필드의 이름, 이를 `uid_val`로 표기합니다. 현재 Typescript SDK는 개발자가 잘못된 JWT 필드를 사용하는 것을 방지하기 위해 subsub 또는 emailemail만 허용합니다. 그러나 검증자들은 어떤 필드든 수용하므로, 고급 사용자가 이 기능을 혁신적으로 사용할 수 있도록 제한하지 않습니다.
    - OIDC 제공자와의 등록 과정에서 발행된 관리 애플리케이션의 식별자(즉, JWT의 audaud 필드에 저장된 OAuth `client_id`), 이를 `aud_val`로 표기합니다.

조금 더 형식적으로(그러나 복잡한 구현 세부 사항은 생략하고), IDC는 SNARK 친화적인 해시 함수 hashhash를 사용하여 위 필드를 해싱하여 계산됩니다 `H` : 
  
![[Pasted image 20240603101247.png]]

#### 페퍼(Peppers)

위에서는 (고엔트로피) 블라인딩 팩터 pepper를 사용하여 IDC를 도출했습니다. 이는 IDC가 사용자의 정체성과 관리 애플리케이션의 정체성에 대한 은닉 커밋먼트임을 보장합니다. 이 AIP 전반에서 이 블라인딩 팩터는 프라이버시 보호 페퍼로 언급됩니다.

페퍼는 두 가지 중요한 속성을 가지고 있습니다:

1. 거래 서명 시 계정 접근 권한을 승인하기 위해 페퍼 pepper의 지식이 필요합니다.
2. 페퍼가 공개되더라도 공격자가 계정에 접근할 수 없습니다. 즉, 비밀 키와 달리 페퍼는 계정의 보안을 보호하기 위해 비밀로 유지될 필요가 없습니다. 계정의 프라이버시만 보호하면 됩니다.

간단히 말해:

- 페퍼를 잃어버리면 계정 접근이 불가능해집니다.
- 페퍼가 공개되거나 도난당하더라도 계정의 프라이버시만 손상됩니다(즉, pepperpepper에 포함된 사용자와 애플리케이션의 정체성이 브루트 포스로 해킹되어 드러날 수 있습니다).

사용자에게 페퍼를 기억하도록 요구하면 비밀 키 기반 계정의 잃기 쉬운 특성을 유지하게 되어 OpenID 기반 블록체인 계정의 목적을 무색하게 만듭니다.

따라서 우리는 사용자가 페퍼를 도출하고 기억하는 것을 돕는 페퍼 서비스를 도입합니다(그 특성은 부록과 AIP-8112에서 간략히 논의합니다).


#### 인증 키(Authentication keys)

다음으로, 키리스 계정의 인증 키는 단순히 앞서 정의한 공개 키의 해시입니다. 더 구체적으로는, 암호화 해시 함수 hash를 가정하면, 인증 키는 다음과 같습니다:

![[Pasted image 20240603101416.png]]

참고: 실제로는 도메인 구분자가 위의 해시에 추가되지만, 설명의 간결성을 위해 이러한 세부 사항은 생략합니다.

#### Secret keys

위에서 "공개 키"를 정의한 후에는 자연스럽게 다음 질문이 제기됩니다:

> 이 공개 키와 관련된 비밀 키는 무엇입니까?

답은 사용자가 추가로 적어야 하는 별도의 비밀 키가 없다는 것입니다. 대신, "비밀 키"는 앞서 정의한 `auth_key`에 포함된 OIDC 계정에 로그인할 수 있는 사용자의 능력으로 구성됩니다.

다시 말해, "비밀 키"는 사용자가 이미 알고 있는 해당 계정의 비밀번호로 생각할 수 있습니다. 또는 사용자가 비밀번호를 다시 입력하지 않아도 되는 미리 설치된 HTTP 쿠키로 생각할 수 있습니다. 그러나 이 비밀번호만으로는 충분하지 않습니다. 관리 애플리케이션은 반드시 사용 가능해야 합니다. 사용자가 OIDC 계정에 로그인하고 OIDC 서명을 받을 수 있어야 합니다. ([애플리케이션이 사라지는 경우 처리하는 방법](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#alternative-recovery-paths-for-when-managing-applications-disappear)에 대해 나중에 논의할 것입니다.)

더 구체적으로, 사용자가 `aud_val`로 식별된 애플리케이션을 사용하여 `iss_val`로 식별된 OIDC 제공자에 의해 발행된 `uid_key, uid_val`로 식별된 OIDC 계정에 (OAuth를 통해) 성공적으로 로그인할 수 있다면, 그 능력이 해당 사용자의 "비밀 키"로 작용합니다.


#### Signatures

먼저 "워밍 업"으로 시작하여 사용자의 개인 정보를 보존하지 않는 "누설 모드" 키리스 서명을 설명하고, 이후 개인 정보를 보존하는 "영 지식" 서명에 대해 설명하겠습니다.

##### _워밍 업_: 사용자와 애플리케이션의 식별 정보를 누설하는 누수 서명

완전한 개인 정보 보호 TXN 서명을 설명하기 전에, 사용자와 애플리케이션의 식별 정보를 누설하는 누수 서명을 설명하여 준비를 합니다. 즉, uid_key, uid_val 및 aud_val이 노출됩니다.

주소의 인증 키가 있는 트랜잭션 txn에 대한 누수 서명 𝜎txn은 다음과 같이 정의됩니다:

𝜎txn=(uid_key,jwt,header,epk,𝜎eph,𝜎oidc,exp_date,𝜌,𝑟,idc_aud_val)σtxn​=(uid_key,jwt,header,epk,σeph​,σoidc​,exp_date,ρ,r,idc_aud_val)

여기서:
1. uid_key는 사용자의 식별 정보를 저장하는 JWT 필드의 이름으로, 해당 값은 주소 IDC에 커밋됩니다.
2. jwt는 JWT 페이로드입니다. (예: [여기에 있는 예제](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#JWT-header-and-payload-example))
3. header는 JWT 헤더로, OIDC 서명 스키마와 JWK의 키 ID를 나타내며, 올바른 PK 하에서 OIDC 서명을 확인하는 데 필요합니다.
4. epk는 관리 애플리케이션이 생성한 **임시 공개 키(EPK)**입니다. (연관된 esk는 관리 애플리케이션 측에서 비밀로 유지됩니다.)
5. 𝜎eph는 트랜잭션 txn에 대한 **임시 서명**입니다.
6. 𝜎oidc는 전체 JWT(즉, header 및 jwt 페이로드)에 대한 OIDC 서명입니다.
7. exp_date는 epk가 만료되어 더 이상 TXN에 사용할 수 없게 되는 타임스탬프입니다.
8. 𝜌는 **EPK 블라인더**로, epk 및 exp_date에 대한 **EPK 커밋먼트**를 생성하는 데 사용됩니다. 이는 jwt["nonce"] 필드에 저장됩니다.
9. 𝑟은 주소 IDC의 페퍼로, 이 "누수 모드"에서는 0으로 가정됩니다.
10. idc_aud_val은 [계정 복구](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#recovery-service)에 사용되는 **선택적** 필드입니다. 설정된 경우, 이 필드에는 IDC에 커밋된 aud 값과 동일한 aud 값이 포함됩니다. 이는 계정 복구 중에 TXN 서명에 포함해야 하는 필수 정보입니다. 이 경우 jwt 페이로드에는 복구 서비스의 aud가 아닌 복구 서비스의 aud가 포함되기 때문입니다.

> 팁
> 
> 간단히 말해서, 서명을 확인하려면, 검증자는 OIDC 제공자가 (1) 주소 IDC에 커밋된 사용자 및 앱 ID를 서명하고(또는, 복구 서비스의 ID) (2) 서명한 EPK가, 턴서 트랜잭션에 서명하고, EPK에 대해 일정한 만료 날짜를 강제합니다.

자세한 내용은 다음과 같습니다. PK (iss_val,addr_idc)에 대한 서명 검증은 다음과 같은 단계를 거칩니다:

1. 이메일 기반 ID를 사용하는 경우, 이메일이 확인되었는지 확인합니다:
    - 즉, uid_key=?"email"이면, jwt["email_verified"]=?"true"임을 확인합니다.
2. uid_val을 jwt[uid_key]로 설정합니다.
3. 만약 idc_aud_val이 설정되어 있다면, jwt["aud"]가 체인에 저장된 [`aud` 오버라이드 목록](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#aud-override-list)에서 승인된 복구 서비스 ID인지 확인합니다.
4. idc_aud_val이 설정되어 있다면, aud_val을 idc_aud_val로 설정하고, 그렇지 않으면 aud_val을 jwt["aud"]로 설정합니다.
5. 주소 IDC가? 𝐻′(uid_key,uid_val,aud_val;𝑟)인지 확인합니다. 이때, 서명에서 pepper인 𝑟를 사용합니다.
6. PK가 체인상의 인증 키와 일치하는지 확인합니다:
    - auth_key가? 𝐻(iss_val,addr_idc)인지 확인합니다.
7. EPK가 JWT의 `nonce` 필드에 커밋되었는지 확인합니다:
    - jwt["nonce"]가? 𝐻′(epk,exp_date;𝜌)인지 확인합니다.
8. EPK 만료 날짜가 너무 미래로 설정되어 있지 않은지 확인합니다 (아래에서 자세히 설명합니다):
    - exp_date가 jwt["iat"]+max_exp_horizon보다 작은지 확인합니다. 여기서 max_exp_horizon은 체인 파라미터입니다 (여기서 참조).
    - (만료 날짜가 미래에 있는지는 확인하지 않습니다 (즉, exp_date>jwt["iat"]를 확인하지 않음). 대신, 발행된 JWT의 타임스탬프 (`iat`) 필드가 올바르며 현재 블록 시간과 가깝다고 가정합니다. 따라서 애플리케이션이 exp_date<jwt["iat"]를 잘못 설정하면 EPK가 블록체인의 관점에서 만료됩니다.)
9. EPK가 만료되지 않았는지 확인합니다:
    - current_block_time()<exp_date를 확인합니다.
10. 턴서 트랜잭션에 대한 EPK에서의 ephemeral signature 𝜎eph를 확인합니다.
11. JWT 헤더에서 `kid` 필드를 통해 식별되는 OIDC 제공자의 올바른 PK를 가져옵니다.
12. JWT 헤더와 페이로드 jwt에서 OIDC 서명 𝜎oidc를 확인합니다.


> 참고
> 
> **JWK 합의:** OIDC 서명을 확인하는 마지막 단계는 검증자들이 OIDC 제공자의 최신 JWK(즉, 공개 키)에 대해 **합의해야 한다는 것**을 요구합니다. 이는 제공자별로 고유한 **OpenID 구성 URL**에서 발행됩니다.
> 
> 이를 위해, 검증자들은 제공자의 JWK를 유지하고 `aptos_framework::jwks` Move 모듈에서 노출할 것입니다. (자세한 내용은 [부록](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#jwk-consensus) 및 AIP-67[14](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#user-content-fn-aip-67-c00900bc08c5d44cdc219c1fc48263d6)을 참조하세요.)

> 참고
> 
> **만료 날짜의 기간이 필요한 이유:** 무지한 dapps가 너무 멀리 떨어진 future에 있는 exp_date를 설정하는 것은 위험할 것으로 생각됩니다. 이렇게 하면 공격자가 서명된 JWT(및 해당 ESK)를 손상시킬 수 있는 시간 창이 길어지게 됩니다. 그 결과로, 우리는 만료 날짜가 너무 멀리 떨어지지 않도록 `iat` JWT 필드와 "만료 기간" max_exp_horizon을 기반으로 합니다. 즉, exp_date<jwt["iat"]+max_exp_horizon을 보장합니다.
> 
> 대안은 exp_date<current_block_time()+max_exp_horizon을 보장하는 것입니다. 그러나 이것은 이상적이지 않습니다. 공격자는 현재 시간을 설정하고 있는 exp_date를 만족시키지 못할 수 있으며 (즉, exp_date≥𝑡1+max_exp_horizon), 나중에 시간이 흐르면 검사를 통과할 수 있습니다(즉, exp_date<𝑡2+max_exp_horizon). 이 설계는 나중에 유효한 (따라서 공격 가능한) 것으로 보이는 서명된 JWT를 허용할 수 있으므로 이 문제를 피하기 위해 `iat`에 의존합니다.

  
다음에 다룰 사항:

- 트랜잭션에 의해 pepper가 노출되어 주소 IDC의 무차별 대입 공격을 허용합니다.
- 마찬가지로, EPK 블라인더가 아직 개인 정보 보호 목적을 이행하지 못하며 TXN에 의해 노출됩니다.
- JWT 페이로드가 평문으로 포함되어 있어 관리 애플리케이션과 사용자의 신원을 노출합니다.
- 심지어 JWT 페이로드가 숨겨져 있더라도 OIDC 서명이 이러한 신원을 노출할 수 있습니다. 서명된 JWT가 저엔트로피일 수 있으므로 공격자는 일반적으로 서명된 JWT의 작은 하위 집합에 대해 서명 검증을 무차별적으로 시도할 수 있습니다.

##### Zero-knowledge signatures

이로써 우리는 이 AIP의 본질에 다다랐습니다: 우리는 이제 키리스 계정을 위한 개인 정보 보호 서명이 어떻게 작동하는지 설명할 준비가 되었습니다. 이러한 서명은 사용자의 OIDC 계정이나 액세스된 키리스 계정과 관련된 관리 앱의 ID에 대해 아무 것도 누설하지 않습니다.

인증 키 auth_key가 있는 주소의 트랜잭션 txn에 대한 **제로 지식 서명** 𝜎txn은 다음과 같이 정의됩니다:

𝜎txn=(header,epk,𝜎eph,exp_date,exp_horizon,extra_field,override_aud_val,𝜎tw,𝜋)

여기서:

3. (header, epk, 𝜎eph, exp_date)는 이전과 같습니다. (이전의 링크 참조)
    
    - 이제 순간적 서명 𝜎eph에는 탈까성 공격에 대비하여 ZKP 𝜋도 포함됩니다.
4. exp_horizon은 max_exp_horizon보다 작거나 같아야 합니다. exp_date는 jwt["iat"]와 jwt["iat"] + exp_horizon 사이에 있어야 합니다.
    
5. extra_field는 선택적 필드로, JWT에서 일치하는 **공개적으로** 공개되는 값입니다. (예: 사용자가 이메일을 공개하려면 `extra_field`를 `"email": "alice@gmail.com"`로 설정)
    
6. override_aud_val은 [계정 복구](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#recovery-service)를 위해 사용되는 선택적 필드입니다. 이 필드가 설정되면 이 값은 숨겨진 ZKP로 인해 JWT 페이로드의 aud 필드와 일치해야 할 재정의 aud 값을 포함합니다. 이 값이 설정되면 ZKP 관계는 aud를 IDC의 aud와 일치시키지 않고 JWT의 aud와 일치시키도록 확인합니다. (위의 leaky mode와 유사)
    
7. 𝜎tw는 ZKP에 대한 선택적 **트레이닝 휠 서명**으로 [트레이닝 휠 모드](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#training-wheels)에 사용됩니다.
    
8. 𝜋은 ZK 관계 𝑅에 대한 **지식의 제로 지식 증명 (ZKPoK)** 으로, 개인 정보 보호 지향 검증을 수행합니다. (아래 논의됨)


> 중요한 점
> 
> 𝜎txn 트랜잭션 서명에는 이제 더 이상 식별 가능한 사용자 정보가 포함되지 않습니다. (iss_val에서 OIDC 제공자의 식별 정보를 제외하고)

> 팁
> 
> **tl;dr**: **𝜎txn 서명을 검증**하기 위해, 검증자는 (1) 주소 IDC에 고정된 사용자 및 앱 ID와 (2) 해당 트랜잭션을 서명한 EPK의 ZKPoK를 확인하면서 EPK에 대한 유효 기간을 적용합니다.

자세한 내용을 살펴보면, PK (iss_val, addr_idc)에 대한 서명 확인은 다음과 같은 단계를 거칩니다:

1. 이전과 마찬가지로 auth_key=?𝐻(iss_val,addr_idc)를 확인합니다.
    
2. 만료 날짜가 정상 범위 내에 있는지 확인합니다:
    
    - 이전과 같이, exp_horizon∈(0,max_exp_horizon)를 확인합니다. 여기서 max_exp_horizon는 이전과 같이 온체인 매개변수입니다.
3. EPK가 만료되지 않았는지 확인합니다:
    
    - 이전과 마찬가지로, current_block_time()<exp_date를 확인합니다.
4. 트랜잭션 txn에 대한 EPK 아래의 에페멀 서명 𝜎eph를 확인합니다.
    
5. 이전과 마찬가지로, jwk​를 통해 OIDC 공급자의 올바른 PK를 가져옵니다.
    
6. **공개 입력 해시**를 유도합니다:
    
    pih=𝐻zk(epk,addr_idc,exp_date,exp_horizon,iss_val,extra_field,header,jwk,override_aud_val)
    
7. 온체인에서 **트레이닝 휠 공개 키**가 설정되었다면 (통치를 통해; 여기를 참조하세요), 다음을 확인합니다:
 - **트레이닝 휠 서명** 𝜎tw가 ZKP 𝜋와 공개 입력 해시 pih에 대해 확인됩니다.
1. ZKPoK 𝜋를 확인합니다. 이것은 아래에 정의된 **ZK relation 𝑅**이라는 ZKPoK를 위한 비밀 입력 w 의 존재를 주장합니다:   

𝑅(pih; w=[wpub=(epk,addr_idc,exp_date,exp_horizon,iss_val,extra_field,header,jwk,override_aud_val), wpriv=(aud_val,uid_key,uid_val,𝑟,𝜎oidc,jwt,𝜌)])

**ZK relation 𝑅**은 단순히 이전의 **누수 모드**에서의 **검증의 프라이버시에 민감한 부분**을 수행합니다:

1. 공개 입력 해시 pih가 wpub의 입력을 𝐻zk로 해싱하여 올바르게 유도되었는지 확인합니다.
   
2. JWT의 OIDC 공급자 ID를 확인합니다:
    - iss_val=?jwt["iss"]를 확인합니다.
      
3. `email` 기반 ID를 사용하는 경우, 이메일이 인증되었는지 확인합니다:
    - uid_key=?"email"이면, jwt["email_verified"]=?"true"를 확인합니다.
      
4. JWT의 사용자 ID를 확인합니다:
    - uid_val=?jwt[uid_key]를 확인합니다.
      
5. 주소 IDC가 올바른 값을 사용하는지 확인합니다:
    - addr_idc=?𝐻′(uid_key,uid_val,aud_val;𝑟)를 확인합니다.
      
6. 복구 모드인가요? (즉, override_aud_val=?⊥인가요)
    - 그렇다면, JWT의 managing application ID를 확인합니다: aud_val=?jwt["aud"]를 주장합니다.
    - 그렇지 않으면, IDC의 aud와 일치하지 않도록 허용하여 JWT의 `aud`가 IDC의 `aud`와 다를 수 있도록 합니다.
      
7. EPK가 JWT의 `nonce` 필드에 포함되어 있는지 확인합니다:
    - jwt["nonce"]=?𝐻′(epk,exp_date;𝜌)를 확인합니다.
      
8. EPK의 만료 날짜가 너무 먼 미래로 설정되지 않았는지 확인합니다:
    - exp_date<jwt["iat"]+exp_horizon를 확인합니다.
      
9. extra_field를 extra_field_key와 extra_field_val로 구문 분석하고 extra_field_val=?jwt[extra_field_key]를 주장합니다.
   
10. OIDC 서명 𝜎oidc가 JWT의 헤더와 페이로드 jwt 위에 jwk를 통해 확인됩니다.

> Tip
> 
> 중요한 것은 ZK proof 𝜋 가 w의 개인 정보를 노출하지 않는다는 점입니다.

> Note
> 
> 추가된 exp_horizon 변수는 간접적인 레이어입니다. 이는 온체인의 max_exp_horizon 매개변수가 변경될 때 ZKP가 새롭지 않게 만듭니다. 왜냐하면 이들은 exp_horizon을 입력으로 사용하고 있기 때문입니다.

**Zero-knowledge 모드의 경고 사항**은 나중에 처리합니다:

1. 페퍼 𝑟 는 사용자/지갑이 페퍼 서비스에서 가져오며, 이를 간략하게 설명합니다. [appendix](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#pepper-service)
2. **ZKP 계산이 느립니다**. 이는 증명 서비스를 필요로 합니다. 이를 간략하게 설명합니다. [appendix](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#(Oblivious)-ZK-proving-service)
3. **ZK relation 구현에서의 버그**는 [“training wheels” 모드](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-61.md#training-wheels) 를 사용하여 완화할 수 있습니다.

  